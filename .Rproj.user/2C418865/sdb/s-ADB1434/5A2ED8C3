{
    "contents" : "##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#'Combine the levels of factor variables.\n#'\n#' @param dafr The dataframe containing factor columns \n#' specified in columns.\n#' @param columns The column names of the columns in dafr \n#' to combine.\n#' \n#' @return A data.frame with one additional column as dafr,\n#' which contains the combined levels.\n#' \n#' @author Christoph Knapp\ncombine.levels = function(dafr,columns){\n  new.column = do.call(paste,lapply(columns,function(name,d){\n    d[,name]\n  },dafr))\n  dafr = cbind(dafr,gsub(\" \",\".\",new.column))\n  colnames(dafr)[ncol(dafr)] = paste(columns,collapse=\".\")\n  dafr\n}\n\n##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#' Renames the levels of a factor.\n#'\n#' @param dafr A data.frame of the data to change.\n#' @param column The column name of the column to change.\n#' @param new.levels A character variabel of the length of \n#' the number of factors of the column to change. This \n#' vector contains the new levels.\n#'\n#' @return A data.frame where the levels of the specified \n#' columns are changed.\n#' \n#' @author Christoph Knapp\nrename.levels = function(dafr,column,new.levels){\n  temp = as.character(dafr[,column])\n  for(i in 1:length(levels(dafr[,column]))){\n    temp[which(dafr[,column]%in%levels(dafr[,column])[i])] = new.levels[i]\n  }\n  dafr[,column] = factor(temp,levels=new.levels)\n  dafr\n}\n\n##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#' This function changes the order of levels in the data.\n#' \n#' @param dafr The data to be changed\n#' @param column the factor column where the order of \n#' levels should be changed.\n#' @param levels.new A vector of all levels in the column \n#' specified by column in the order they should be \n#' ordered.\n#' \n#' @return A data.frame with the levels of one column \n#' reordered\n#' \n#' @author Christoph Knapp\nreorder.levels = function(dafr,column,levels.new){\n  dafr[,column] = factor(dafr[,column],levels=levels.new)\n  dafr\n}\n\n##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#' Collapses selected levels in factor vector\n#' \n#' @param column the vector where levels should be \n#' collapsed into one.\n#' @param to.collapse Vector of levels to collapse.\n#' \n#' @note Levels in to.collapse which are not in column \n#' will be ignored.\n#' \n#' @author Christoph Knapp\nget.collapsed.column = function(column,to.collapse){\n  column = as.character(column)\n  new.level = paste(to.collapse,collapse=\".\")\n  indices = which(column%in%to.collapse)\n  if(length(indices)>0){\n    column[indices] = new.level\n  }\n  as.factor(column)\n}\n\n##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#' Stacks the selected columns onto the data.\n#'\n#' Multiplies the data.set by adding rows to the data for \n#' every selected column. The selected columns are stacked\n#' onto each other and added as an additional column \n#' \n#' @param columns The columns to stack.\n#' @param dafr a dataframe the stacking is performed on.\n#' \n#' @author Christoph Knapp\nstack.variables.perform = function(columns,dafr){\n  stack = unlist(lapply(1:length(columns),function(index,d,c){\n    d[,which(colnames(d)%in%c[index])]\n  },dafr,columns))\n  colstack = unlist(lapply(1:length(columns),function(index,d,c){\n    rep(c[index],nrow(d))\n  },dafr,columns))\n  cbind(dafr,stack.columns=colstack,stack.variables=stack)\n}\n\n##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#' aggregates the data over selected factor columns\n#' \n#' The dimensions of the df data frame will change so that \n#' all possible combinations of factors selected will be \n#' the number of rows and the number of all selected factor \n#' columns + a column for all methods selected will be the \n#' number of columns in the return data.frame. \n#' \n#' @param aggregate.over column names of factor variables \n#' in data to aggregate over\n#' @param methods A set of methods which can be used to \n#' aggregate.\n#' @param df A data.frame containing at least on factor \n#' column and one numeric column.\n#' \n#' @return A data.frame with the results of the aggregation.\n#' \n#' @author Christoph Knapp  \naggregate.data= function(aggregate.over,\n                         methods=c(\"mean\",\"median\",\"sum\",\"sd\",\"IQR\",\"count\"),\n                         dafr){\n  if(is.null(aggregate.over)|is.null(methods)|length(methods)==0|\n       length(aggregate.over)==0|is.numeric(aggregate.over)){\n    stop(\"aggregate.data : Wrong input\")\n  }\n  if(any(!as.character(aggregate.over)%in%colnames(dafr))){\n    warning(\"aggregate.data : Some columns in aggregate.over are \n            not in the column names for df. They will be ignored.\")\n  }\n  if(is.character(aggregate.over)){\n    aggregate.over = as.factor(aggregate.over)\n  }\n  bys = lapply(1:length(aggregate.over),\n               function(i,d,v){\n                 d[,which(colnames(d)%in%v[i])]\n               },dafr,aggregate.over)\n  names(bys) = aggregate.over\n  sets = lapply(1:length(methods),function(i,d,b,m){\n    if(\"count\"%in%m[i]){\n      m[i] = \"length\"\n      temp = aggregate(d[,unlist(lapply(1:ncol(d),\n                                        function(j,da){\n                                          is.numeric(da[,j])\n                                        },d))], \n                       by=b, FUN=m[i],simplify = FALSE)\n    }else{\n      temp = aggregate(d[,unlist(lapply(1:ncol(d),\n                                        function(j,da){\n                                          is.numeric(da[,j])\n                                        },d))], \n                       by=b, FUN=m[i],na.rm=T,simplify = FALSE)\n    }\n    \n    colnames(temp)[(length(b)+1):ncol(temp)] = paste(m[i],\n                                                     colnames(temp)[(length(b)+1):ncol(temp)],sep=\".\")\n    temp\n  },dafr,bys,methods)\n  temp = sets[[1]]\n  if(length(sets)>1){\n    for(i in 2:length(sets)){\n      temp = merge(temp,sets[[i]])\n    }\n  }\n  temp\n  }\n\n##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#' Sorts the df data frame after the input variables\n#' \n#' Warnings will be given if the colnames in vars will not \n#' match the column in df. This is a wrapper function for \n#' sort. See \\code{?sort} for more information.\n#' \n#' @param vars The column names in the order the df data.frame\n#' should be sorted.\n#' @param sort.type A logical vector of the same length as \n#' vars. If the element in the vector is TRUE the corresponding \n#' element in vars will be sorted in increasing order.\n#' @ param The data.fram or matrix to sort.\n#' \n#' @return An ordered data.frame\n#' \n#' @author Christoph Knapp  \nsort.data = function(vars,sort.type,df){\n  if(any(!vars%in%colnames(df))){\n    warning(\"sort.data : Not all variables in vars could be \n            matched to column names in df.\")\n  }\n  if(length(vars)!=length(sort.type)){\n    stop(\"sort.data : vas and sort.type have different length\")\n  }\n  z = lapply(1:length(vars),function(index,v,t,d){\n    vec = d[,which(colnames(d)%in%v[index])]\n    if(is.factor(vec)|is.character(vec)){\n      vec = xtfrm(as.character(vec))\n    }\n    if(!t[index]){\n      vec = -vec\n    }\n    vec\n  },vars,sort.type,df)\n  df[order.overwrite(z),]\n  }\n\n#' The iNZight version of the order function which lets you pass \n#' in a list of vectors to order instead of the ... argument. It \n#' is shortened and might be therefore not as stable as the \n#' original order function.\n#' \n#' @param z a sequence of numeric, complex, character or logical \n#' vectors, all of the same length, or a classed R object.\n#' @param na.last for controlling the treatment of NAs. If TRUE, \n#' missing values in the data are put last; if FALSE, they are \n#' put first; if NA, they are removed (see ‘Note’.)\n#' @param decreasing logical. Should the sort order be increasing \n#' or decreasing?\n#' \n#' @note This function is only called in sort.data but needs to be \n#' available to sort.data\n#' \n#' @author Christoph Knapp\norder.overwrite = function (z, na.last = TRUE, decreasing = FALSE) {\n  if (any(diff(l.z <- vapply(z, length, 1L)) != 0L)) \n    stop(\"argument lengths differ\")\n  ans <- vapply(z, is.na, rep.int(NA, l.z[1L]))\n  ok <- if (is.matrix(ans)) \n    !apply(ans, 1, any)\n  else !any(ans)\n  if (all(!ok)) \n    return(integer())\n  z[[1L]][!ok] <- NA\n  ans <- do.call(\"order\", c(z, decreasing = decreasing))\n  keep <- seq_along(ok)[ok]\n  ans[ans %in% keep]\n}\n\n\n##########################################################\n#To be removed when the iNZight tools package is working##\n##########################################################\n#' Takes a sample of rows from a data.frame\n#' \n#' This function samples rows from a data.frame with or \n#' without replacment. \n#' \n#' @param df A data.frame the sample is taken from.\n#' @param sampleSize The size of the samples to be taken.\n#' @param numSample The number of samples to be taken.\n#' @param bootstrap TRUE if samples with replacement is \n#' desired, FALSE if no replacement.\n#' \n#' @return A data.frame with the samples merged together. \n#' An additional column is added where the sampling \n#' iteration is stored. \n#' \n#' @author Christoph Knapp\n#' \n#' @export\nsample.data = function(df,sampleSize,numSample=1,bootstrap=F){\n  if(sampleSize>nrow(df)){\n    stop(paste0(\"This sample is to large. Only \",nrow(df),\" samples available.\"))\n  }\n  if(sampleSize*numSample>nrow(df)&!bootstrap){\n    stop(paste0(\"Not enough rows in data to sample that many times.\"))\n  }\n  colname = \"num.sample\"\n  if(\"num.sample\"%in%colnames(df)){\n    count=1\n    while(paste0(\"num.sample\",count)%in%colnames(df)){\n      count = count+1\n    }\n    colname = paste0(\"num.sample\",count)\n  }\n  ret = NULL\n  if(bootstrap){\n    ret = do.call(rbind,lapply(1:numSample,function(index,d,size){\n      cbind(d[sample(1:nrow(d),size),],rep(index,size))\n    },df,sampleSize))\n  }else{\n    ret = do.call(rbind,lapply(1:numSample,function(index,d,size){\n      s = sample(1:nrow(d),size)\n      temp = cbind(d[s,],rep(index,size))\n      d <<- d[-s,]\n      temp\n    },df,sampleSize))\n  }\n  colnames(ret)[ncol(ret)] = colname\n  ret\n}\n\n#' Returns the names of all numeric columns in data \n#' \n#' @author Christoph Knapp\nget.numeric.column.names = function(dafr){\n  colnames(dafr)[which(unlist(lapply(1:ncol(dafr),function(index,d){\n    is.numeric(as.data.frame(d)[,index])\n  },dafr)))]\n}\n\n#' Returns TRUE if x can be converted to a numeric \n#' value, FALSE if not. \n#' \n#' @param x any oblect to be tested\n#' \n#' @author Christoph Knapp\nis.convertable.numeric = function(x){\n  if(suppressWarnings(any(is.na(as.numeric(x))))){\n    F\n  }else{\n    T\n  }\n}\n\n#' Prints a summary of the currently selected data set.\n#' \n#' @author Christoph Knapp\ndata.summary = function(dafr){  \n  if(!is.null(dafr)){\n    cat(\"Number of rows in data: \",nrow(dafr),\"\\n\")\n    cat(\"Number of columns in data: \",ncol(dafr),\"\\n\")\n    cat(\"\\n\")\n    for(col in 1:length(colnames(dafr))){\n      cat(colnames(dafr)[col],\"\\n\")\n      print(summary(dafr[,col]))\n    }\n  }\n}\n\n\n#' Returns the column names of the currently selected data which\n#' can be converted into factors.\n#' \n#' @author Christoph Knapp\nget.categorical.column.names = function(dafr){\n  colnames(dafr)[which(unlist(lapply(1:ncol(dafr),function(index,d){\n    class(as.data.frame(d)[,index])%in%\"factor\"||class(as.data.frame(d)[,index])%in%\"character\"\n  },dafr)))]\n}\n\n# #' Creates a widget for moving through plots quickly.\n# #' \n# #' @param ID.forward inputID for the forward button in the player widget\n# #' @param ID.player inputID for the slider in the player widget\n# #' @param ID.backward inputID for the backward button in the player widget\n# #' \n# #' @author Christoph Knapp\n# get.player = function(ID.forward,ID.player,ID.backward,maxi){\n#   fixedRow(column(width=8,offset=2,\n#                   div(class='player',\n#                       fixedRow(\n#                         column(width=1,offset=1,\n#                                div(class=\"seper\",actionButton(inputId=ID.backward,label=\"\",icon=icon(\"backward\")))),\n#                         column(width=6,offset=1,\n#                                sliderInput(inputId=ID.player,label=\"\",min=1,max=maxi,step=1,\n#                                            animate=animationOptions(interval=500,loop=T,play=T),\n#                                            width=\"100%\",value=1,ticks=F)),\n#                         column(width=1,offset=1,\n#                                div(class=\"seper\",actionButton(inputId=ID.forward,label=\"\",icon=icon(\"forward\"))))\n#                       ))))\n# }\n#' Creates a widget for moving through plots quickly.\n#'\n#' @param ID.forward inputID for the forward button in the player widget\n#' @param ID.player inputID for the slider in the player widget\n#' @param ID.backward inputID for the backward button in the player widget\n#'\n#' @author Christoph Knapp\nget.player = function(ID.forward,ID.player,ID.backward,maxi){\n  fixedRow(column(width=8,offset=2,\n                  div(class='player',\n                      fixedRow(\n                        column(width=1,offset=1,\n                               div(class=\"seper\",\n                                   actionButton(inputId=ID.backward,\n                                                label=\"\",icon=icon(\"backward\")))),\n                        column(width=6,offset=1,\n                               sliderInput(inputId=ID.player,label=\"\",min=1,max=maxi,step=1,\n                                           animate=animationOptions(interval=500,loop=T,play=T),\n                                           width=\"100%\",value=1,ticks=F)),\n                        column(width=1,offset=1,\n                               div(class=\"seper\",actionButton(inputId=ID.forward,label=\"\",icon=icon(\"forward\"))))\n                      ))))\n}\n\nchange.factor.transform = function(temp,columns){\n  temp = as.data.frame(temp)\n  nums = unlist(lapply(1:ncol(temp),function(index,temp.data,columns){\n    if(is.numeric(temp.data[,index])){\n      columns[index]\n    }else{\n      NULL\n    }\n  },temp,columns))\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(temp),function(index,temp.data){\n    if(is.numeric(temp.data[,index])){\n      as.character(temp.data[,index])\n    }else{\n      NULL\n    }\n  },temp)),stringsAsFactors=T)\n  if(!is.null(temp)&&ncol(temp)>0&&nrow(temp)>0){\n    colnames(temp) = paste(\"factors\",nums,sep=\"_\")\n    temp\n  }else{\n    NULL\n  }\n}\n\nchange.sign.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,dafr){\n    if(is.numeric(dafr[,index])){\n      as.matrix(dafr[,index]*(-1))\n    }else{\n      NULL\n    }\n  },dafr)))\n  if(!is.null(temp)){\n    colnames(temp) = paste(\"change_sign\",columns[unlist(lapply(1:ncol(dafr),function(i,d){\n      is.numeric(d[,i])\n    },dafr))],sep=\".\")\n  }\n  temp\n}\n\ntest.for.dates = function(dafr){\n  ret = F\n  if(!is.null(dafr)){\n    ret = unlist(lapply(\n      1:ncol(dafr),function(index,d){\n        tryCatch({\n          is.numeric(as.numeric(as.Date(d[,index], origin = \"1900-01-01\")))\n        },\n        error=function(cond) {\n          ret = F\n        },\n        warning=function(cond) {\n          print(cond)\n        },\n        finally={})\n      },dafr))\n  }\n  ret\n}\n\ncopy.transform = function(dafr,columns){\n  data = as.data.frame(dafr)\n  colnames(dafr) = paste(\"copy\",columns,sep=\".\")\n  data\n}\n\nreverse.coding.transform = function(dafr,columns){\n  data = as.data.frame(dafr)\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,d){\n    if(is.numeric(d[,index])){\n      min(d[,index],na.rm=T)+max(d[,index],na.rm=T)-d[,index]\n    }else{\n      NULL\n    }\n  },dafr)))\n  if(!is.null(temp)){\n    colnames(temp) = paste(\"reverse_coding\",\n                           columns[unlist(lapply(1:ncol(dafr),\n                                                 function(i,d){\n                                                   is.numeric(d[,i])\n                                                 },dafr))],sep=\".\")\n  }\n  temp\n}\n\nmedian.split.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  nums = unlist(lapply(1:ncol(dafr),function(index,dafr){is.numeric(dafr[,index])},dafr))\n  dafr = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,d){\n    if(is.numeric(d[,index])){\n      med = median(d[,index],na.rm=T)\n      ret = rep(\"high\",length(d[,index]))\n      ret[which(d[,index]<=med)] = \"low\"\n      ret\n    }else{\n      NULL\n    }\n  },dafr)),stringsAsFactors=T)\n  colnames(dafr) = paste(\"median_split\",columns[nums],sep=\"_\")\n  dafr\n}\n\nstandardize.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  dafr = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,d){\n    if(is.numeric(d[,index])){\n      (d[,index]-mean(d[,index],na.rm=T))/sd(d[,index],na.rm=T)\n    }else{\n      (as.numeric(factor(d[,index]))\n       -mean(as.numeric(factor(d[,index])),na.rm=T))/\n        sd(as.numeric(factor(d[,index])),na.rm=T)\n    }\n  },dafr)))\n  colnames(dafr) = paste(\"standardize\",columns,sep=\".\")\n  dafr\n}\n\ncenter.transform = function(dafr,columns){\n  data = as.data.frame(dafr)\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,d){\n    if(is.numeric(d[,index])){\n      d[,index]-mean(d[,index])\n    }else{\n      as.numeric(factor(d[,index]))-mean(as.numeric(factor(d[,index])))\n    }\n  },dafr)))\n  colnames(temp) = paste(\"center\",columns,sep=\".\")\n  temp\n}\n\ndivide.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  colnames(dafr) = columns\n  if(is.null(dafr)){\n    return(NULL)\n  }else{\n    if(ncol(as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n      is.numeric(d[,index])\n    },dafr))]))==1){\n      temp = as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))])\n      colnames(temp) = colnames(data)[unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },data))]\n    }else if(ncol(as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n      is.numeric(d[,index])\n    },data))]))>1){\n      temp = as.data.frame(divide(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])},dafr))]))\n      colnames(temp) = paste0(\"divide.\",\n                              paste(colnames(dafr)[unlist(lapply(1:ncol(dafr),function(index,d){\n                                is.numeric(d[,index])\n                              },dafr))],collapse=\".\"))\n    }else{\n      return(NULL)\n    }\n  }\n  temp\n}\n\ndivide = function(dafr){\n  dafr = dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n    is.numeric(d[,index])\n  },dafr))]\n  dafr = as.data.frame(dafr)\n  if(ncol(dafr)==1){\n    dafr[,1]\n  }else{\n    start = dafr[,1]\n    for(col in 2:ncol(dafr)){\n      start = start/dafr[,col]\n    }\n    start\n  }\n}\n\nmultiply.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  colnames(dafr) = columns\n  if(is.null(dafr)){\n    return(NULL)\n  }else{\n    if(ncol(as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n      is.numeric(d[,index])\n    },dafr))]))==1){\n      temp = as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))])\n      colnames(temp) = colnames(dafr)[unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))]\n    }else if(ncol(as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n      is.numeric(d[,index])\n    },dafr))]))>1){\n      temp = as.data.frame(multiply(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))]))\n      colnames(temp) = paste0(\"multiply.\",paste(colnames(dafr)[unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))],collapse=\".\"))\n    }else{\n      return(NULL)\n    }\n  }\n  temp\n}\n\nmultiply = function(dafr){\n  dafr = dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n    is.numeric(d[,index])\n  },dafr))]\n  dafr = as.data.frame(dafr)\n  if(ncol(dafr)==1){\n    dafr[,1]\n  }else{\n    start = dafr[,1]\n    for(col in 2:ncol(dafr)){\n      start = start*dafr[,col]\n    }\n    start\n  }\n}\n\nsubtract.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  colnames(dafr) = columns\n  if(is.null(dafr)){\n    return(NULL)\n  }else{\n    if(ncol(as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n      is.numeric(d[,index])\n    },dafr))]))==1){\n      temp = as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))])\n      colnames(temp) = colnames(dafr)[unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))]\n    }else if(ncol(as.data.frame(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n      is.numeric(d[,index])\n    },dafr))]))>1){\n      temp = as.data.frame(subtract(dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))]))\n      colnames(temp) = paste0(\"subtract.\",paste(colnames(dafr)[unlist(lapply(1:ncol(dafr),function(index,d){\n        is.numeric(d[,index])\n      },dafr))],collapse=\".\"))\n    }else{\n      return(NULL)\n    }\n  }\n  temp\n}\n\nsubtract = function(dafr){\n  dafr = dafr[,unlist(lapply(1:ncol(dafr),function(index,d){\n    is.numeric(d[,index])\n  },dafr))]\n  dafr = as.data.frame(dafr)\n  if(ncol(dafr)==1){\n    dafr[,1]\n  }else{\n    start = dafr[,1]\n    for(col in 2:ncol(dafr)){\n      start = start-dafr[,col]\n    }\n    start\n  }\n}\n\nadd.transform  = function(temp,columns){\n  temp = as.data.frame(temp)\n  colnames(temp) = columns\n  if(is.null(temp)){\n    return(NULL)\n  }else{\n    ret = as.data.frame(temp[,unlist(lapply(1:ncol(temp),function(index,d){\n      is.numeric(d[,index])\n    },temp))])\n    if(ncol(ret)>1){\n      ret = as.data.frame(apply(ret,1,function(row){sum(row)}))\n      colnames(ret) = paste0(\"add_\",paste(colnames(temp),collapse=\"_\"))\n    }else{\n      return(NULL)\n    }\n  }\n  ret\n}\n\n# returns the transformed columns and the original data as \n# dataframe (cbind(data,<transformed columns>)).\ntransform.perform = function(dafr,type,columns){\n  temp = transform.get.temp(dafr,type,columns)\n  if(!is.null(temp)){\n    temp = cbind(dafr,temp)\n  }\n  temp\n}\n\n# returns the transformed columns and the original columns as \n# dataframe (cbind(<original columns>,<transformed columns>)).\ntransform.tempTable = function(dafr,type,columns){\n  temp1 = as.data.frame(dafr[,which(colnames(dafr)%in%columns)])\n  temp2 = transform.get.temp(dafr,type,columns)\n  if(!is.null(temp2)){\n    temp1 = cbind(temp1,temp2)\n  }\n  temp1\n}\n\n# transorms the columns named columns in data with the selected \n# type (type) of transformation.\ntransform.get.temp = function(dafr,type,columns){\n  temp = NULL\n  if (!is.null(columns) && type%in%\"log\"){\n    temp = log.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"add\"){\n    temp = add.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"subtract\"){\n    temp = subtract.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"multiply\"){\n    temp = multiply.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"divide\"){\n    temp = divide.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"root\"){\n    temp = root.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"square\"){\n    temp = square.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"abs\"){\n    temp = abs.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"center\"){\n    temp = center.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"standardize\"){\n    temp = standardize.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"median split\"){\n    temp = median.split.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"reverse-coding\"){\n    temp = reverse.coding.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"copy\"){\n    temp = copy.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"change sign\"){\n    temp = change.sign.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"change to factor\"){\n    temp = change.factor.transform(dafr[,columns],columns)\n  } else if (!is.null(columns)&type%in%\"\"){\n    temp = NULL\n  }\n  temp\n}\n\nlog.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  colnames(dafr) = columns\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,dafr){\n    if(is.numeric(dafr[,index])){\n      log(dafr[,index])\n    }else{\n      NULL\n    }\n  },dafr)))\n  if(!is.null(temp)&&dim(temp)[1]>0&&dim(temp)[2]>0){\n    colnames(temp) = unlist(lapply(1:ncol(dafr),function(index,dafr){\n      if(is.numeric(dafr[,index])){\n        paste0(\"log.\",colnames(dafr)[index])\n      }else{\n        NULL\n      }\n    },dafr))\n    temp\n  }else{\n    NULL\n  }\n}\n\nroot.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  colnames(dafr) = columns\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,d){\n    if(is.numeric(d[,index])){\n      sqrt(d[,index])\n    }else{\n      NULL\n    }\n  },dafr)))\n  ##  temp = as.data.frame(temp)\n  if(dim(temp)[1]>0&&dim(temp)[2]>0){\n    colnames(temp) = unlist(lapply(1:ncol(dafr),function(index,d){\n      if(is.numeric(d[,index])){\n        paste0(\"root.\",colnames(d)[index])\n      }else{\n        NULL\n      }\n    },dafr))\n    temp\n  }else{\n    NULL\n  }\n}\n\nsquare.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  colnames(dafr) = columns\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,d){\n    if(is.numeric(d[,index])){\n      d[,index]^2\n    }else{\n      NULL\n    }\n  },dafr)))\n  ##  temp = as.data.frame(temp)\n  if(dim(temp)[1]>0&&dim(temp)[2]>0){\n    colnames(temp) = unlist(lapply(1:ncol(dafr),function(index,d){\n      if(is.numeric(d[,index])){\n        paste0(\"square.\",colnames(d)[index])\n      }else{\n        NULL\n      }\n    },dafr))\n    temp\n  }else{\n    NULL\n  }\n}\n\nabs.transform = function(dafr,columns){\n  dafr = as.data.frame(dafr)\n  colnames(dafr) = columns\n  temp = as.data.frame(do.call(cbind,lapply(1:ncol(dafr),function(index,d){\n    if(is.numeric(d[,index])){\n      abs(d[,index])\n    }else{\n      NULL\n    }\n  },dafr)))\n  #   temp = as.data.frame(temp)\n  if(dim(temp)[1]>0&&dim(temp)[2]>0){\n    colnames(temp) = unlist(lapply(1:ncol(dafr),function(index,d){\n      if(is.numeric(d[,index])){\n        paste0(\"abs.\",colnames(d)[index])\n      }else{\n        NULL\n      }\n    },dafr))\n    temp\n  }else{\n    NULL\n  }\n}\n\ndelete.old.files = function(data_dir,days){\n  if(length(list.files(paste0(data_dir,\"/Imported\")))>0){\n    unlink(list.files(paste0(data_dir,\"/Imported\"))\n           [difftime(Sys.time(), \n                     file.info(list.files(\n                       paste0(data_dir,\"/Imported\"),full.name=T))\n                     [,\"mtime\"], units = \"days\")>days])\n  }\n}\n\n###  A function for displaying help messages.\n\nhelp.display = function(title, id, file) {\n  HTML(paste(\"<div class='modal fade' id='\", id, \"' tabindex='-1' role='dialog' aria-labelledby='basicModal' aria-hidden='true'>\n             <div class='modal-dialog'>\n             <div class='modal-content'>\n             <div class='modal-header'>\n             <h4 class='modal-title' id='myModalLabel'>\",title,\"</h4>\n             </div>\n             <div class='modal-body'>\",\n             markdownToHTML(\n               file = file,\n               options = c(\"\"),\n               stylesheet = \"www/empty.css\"),\n             \"</div>\n             <div class='modal-footer'>\n             </div>\n             </div>\n             </div>\n             </div>\n             <a href='#' class='btn btn-xs btn-success' data-toggle='modal' data-target='#\", id, \"'>Help</a>\", sep = \"\"))\n}\n\n## reads a data set from a filename in the data directory\nload.data = function(data_dir,fileID=NULL,path=NULL){\n  temp = NULL\n  full.name = list.files(data_dir,full.names=T,recursive=T)\n  if(!is.null(fileID)){\n    if(is.null(path)){\n      indexes = grep(paste(fileID,\".\",sep=\"\"),full.name,fixed=T)\n    }else if(!is.null(path)&file.exists(path)){\n      full.name = path\n      indexes = 1\n    }else{\n      return(list(NULL,NULL))\n    }\n    if(length(indexes[1])>0){\n      ext = strsplit(full.name[indexes[1]],\".\",fixed=T)[[1]]\n      ext = ext[length(ext)]\n      if(!(tolower(ext)%in%c(\"rds\",\"rda\",\"rdata\",\"csv\",\"txt\"))){\n        ext = strsplit(fileID,\".\",fixed=T)[[1]]\n        ext = ext[length(ext)]\n      }\n      if(!file.exists(full.name[indexes[1]])){\n        return(list(NULL,NULL))\n      }\n      if(tolower(ext)%in%\"rds\"){\n        temp = readRDS(file=full.name[indexes[1]])\n      }else if(tolower(ext)%in%\"rda\"|tolower(ext)%in%\"rdata\"){\n        name = load(full.name[indexes[1]])\n        temp = get(name)\n      }else if(tolower(ext)%in%\"csv\"){\n        temp = read.csv(full.name[indexes[1]])\n      }else if(tolower(ext)%in%\"txt\"){\n        temp = read.delim(full.name[indexes[1]])\n      }\n    }\n  }\n  if(is.null(fileID)){\n    list(NULL,temp)\n  }else{\n    list(basename(fileID),temp)\n  }\n}\n\n## returns directories in the data directory\nget.data.dirs = function(data_dir){\n  list.files(data_dir,\n             include.dirs=T,\n             full.names=T)[file.info(paste(data_dir,\n                                           list.files(data_dir),\n                                           sep=\"/\"))[,\"isdir\"]]\n}\n\n## returns a radioButton widget, for every filename in the dir.lable directory.\nget.radio.list = function(dir.label,idlabel){\n  files = c()\n  files = list.files(dir.label,\n                     recursive=T,\n                     full.name=T)[!(file.info(list.files(dir.label,\n                                                         recursive=T,\n                                                         full.names=T))[,\"isdir\"])]\n  temp.files = strsplit(files,\"/\")\n  files = unlist(lapply(temp.files,\n                        function(x,label){\n                          paste(x[(which(x%in%label)+1):length(x)],collapse=\"==>\")\n                        },strsplit(dir.label,\"/\",fixed=T)[[1]][length(strsplit(dir.label,\"/\",fixed=T)[[1]])]))\n  ret=NULL\n  if(length(files)>0){\n    columns = lapply(1:length(files),\n                     function(i,ns){\n                       paste(strsplit(ns[i],\".\",fixed=T)[[1]][1:(length(strsplit(ns[i],\".\",fixed=T)[[1]])-1)],collapse=\".\")\n                     },\n                     basename(files))\n    ret=radioButtons(inputId=paste(basename(dir.label),idlabel,sep=\"\"), label=basename(dir.label), choices=columns, selected=columns[1])\n  }\n  ret\n}\n\nchange.file.ext = function(name,new.ext){\n  splity = strsplit(name,\".\",fixed=T)[[1]]\n  if(length(splity)>1){\n    splity = paste(paste(splity[1:(length(splity)-1)],collapse=\".\"),new.ext,sep=\".\")\n  }else{\n    splity = paste0(splity,\".\",new.ext)\n  }\n  splity\n}\n\nget.vars = function(data_dir){\n  lines = c()\n  if(file.exists(\"VARS\")){\n    lines = scan(\"VARS\",what=\"character\",sep=\"\\n\",quiet=T)\n  }\n  if(length(lines)>0){\n    invisible(lapply(lines,function(line){\n      if(length(strsplit(line,\"#\")[[1]])>0){\n        line=strsplit(line,\"#\")[[1]][1]\n      }\n      if(!\"\"%in%line){\n        variable = gsub(\"^\\\\s+|\\\\s+$\", \"\", strsplit(line,\"=\")[[1]])\n        if(length(variable)!=2){\n          message(paste(\"Format of variable:\",paste(variable,collapse=\" \"),\"\\n is not valid.\",sep=\" \"))\n        }else{\n          if(variable[1]%in%vars&&!\"\"%in%variable[2]){\n            if(variable[1]%in%\"data.dir\"){\n              data_dir<<-variable[2]\n            }else if(variable[1]%in%\"version\"){\n              version<<-variable[2]\n            }\n          }\n        }\n      }\n    }))\n  }\n}\n\nget.quantiles = function(subx){\n  g1 = rep(\"\",length(subx))\n  if(is.numeric(subx)){\n    quant = quantile(subx,na.rm=T)\n    g1[which(subx>=quant[1]&subx<quant[2])] = paste(round(quant[1],2),round(quant[2],2),sep=\"-\")\n    g1[which(subx>=quant[2]&subx<quant[3])] = paste(round(quant[2],2),round(quant[3],2),sep=\"-\")\n    g1[which(subx>=quant[3]&subx<xquant[4])] = paste(round(quant[3],2),round(quant[4],2),sep=\"-\")\n    g1[which(subx>=quant[4]&subx<=quant[5])] = paste(round(quant[4],2),round(quant[5],2),sep=\"-\")\n    g1 = as.factor(g1)\n  }\n  g1\n}\n\n",
    "created" : 1428622570593.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3577250723",
    "id" : "5A2ED8C3",
    "lastKnownWriteTime" : 1428622603,
    "path" : "~/git/Lite/functions.R",
    "project_path" : "functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}